import type { NextConfig } from 'next';
import type { Compiler, WebpackPluginInstance } from 'webpack';
import * as path from 'path';
import * as fs from 'fs/promises';
import type { PluginConfig } from '../core/types';
import { ProjectAnalyzer } from '../core/analyzer';
import { createDefaultConfig, validateConfig } from '../core/config';
import { FileWriter } from '../core/output/file-writer';
import { ApiSender } from '../core/output/api-sender';

export interface NextPluginOptions extends Partial<PluginConfig> {
  /**
   * 분석 실행 시점
   * - 'build': 프로덕션 빌드 시에만 (기본값)
   * - 'dev': 개발 모드 시에만
   * - 'both': 둘 다
   */
  runOn?: 'build' | 'dev' | 'both';
}

/**
 * 메타데이터 분석 실행 함수 (재사용)
 */
async function runMetadataAnalysis(
  pluginConfig: PluginConfig,
  rootDir: string
): Promise<void> {
  const analyzer = new ProjectAnalyzer(pluginConfig);
  const fileWriter = new FileWriter(pluginConfig);
  const apiSender = pluginConfig.output.api?.enabled
    ? new ApiSender(pluginConfig)
    : null;

  if (pluginConfig.verbose) {
    console.log('[metadata-plugin] Starting analysis...');
  }

  const result = await analyzer.analyze(rootDir);

  // 파일 출력
  if (pluginConfig.output.file?.enabled) {
    const outputPath = path.resolve(rootDir, pluginConfig.output.file.path);
    await fileWriter.write(result, outputPath);

    if (pluginConfig.verbose) {
      console.log(`[metadata-plugin] Wrote metadata to ${outputPath}`);
    }
  }

  // API 전송
  if (apiSender) {
    await apiSender.send(result);

    if (pluginConfig.verbose) {
      console.log('[metadata-plugin] Sent metadata to API');
    }
  }
}

/**
 * Next.js 16+ Build Adapter 생성
 * Turbopack 환경에서도 동작하는 빌드 어댑터
 */
export function createMetadataAdapter(options: NextPluginOptions = {}) {
  const pluginConfig = createDefaultConfig(options);

  // 설정 검증
  const errors = validateConfig(pluginConfig);
  if (errors.length > 0) {
    throw new Error(
      `[metadata-plugin] Invalid config:\n${errors.join('\n')}`
    );
  }

  return {
    name: 'metadata-adapter',

    async onBuildComplete({
      projectDir,
    }: {
      routes: unknown;
      outputs: unknown;
      projectDir: string;
      repoRoot: string;
      distDir: string;
      config: NextConfig;
      nextVersion: string;
    }) {
      if (pluginConfig.verbose) {
        console.log('[metadata-plugin] Build completed, running analysis...');
      }

      await runMetadataAnalysis(pluginConfig, projectDir);

      if (pluginConfig.verbose) {
        console.log('[metadata-plugin] Analysis completed');
      }
    },
  };
}

/**
 * Next.js 16+ 어댑터 파일 생성 헬퍼
 * Turbopack 지원을 위해 어댑터 파일을 자동 생성
 */
export async function generateAdapterFile(
  projectDir: string,
  options: NextPluginOptions = {}
): Promise<string> {
  const adapterPath = path.join(projectDir, '.metadata-adapter.js');

  const adapterContent = `
// Auto-generated by metadatafy
// This adapter enables metadata extraction with Turbopack (Next.js 16+)

const { createMetadataAdapter } = require('metadatafy/next');

module.exports = createMetadataAdapter(${JSON.stringify(options, null, 2)});
`;

  await fs.writeFile(adapterPath, adapterContent.trim());
  return adapterPath;
}

/**
 * Next.js 설정을 확장하는 함수
 * Next.js 16+ Turbopack: experimental.adapterPath 사용
 * Next.js 15- Webpack: webpack 플러그인 사용
 */
export function withMetadata(
  options: NextPluginOptions = {}
): (nextConfig: NextConfig) => NextConfig {
  const pluginConfig = createDefaultConfig(options);
  const runOn = options.runOn || 'build';

  // 설정 검증
  const errors = validateConfig(pluginConfig);
  if (errors.length > 0) {
    throw new Error(
      `[metadata-plugin] Invalid config:\n${errors.join('\n')}`
    );
  }

  return (nextConfig: NextConfig): NextConfig => {
    // Next.js 16+ Turbopack 지원: experimental.adapterPath
    // 사용자가 직접 어댑터 설정을 추가해야 함
    // 이 함수는 webpack 폴백도 제공

    return {
      ...nextConfig,

      webpack(config, context) {
        const { dev, isServer } = context;

        // 서버 사이드에서만 실행 (클라이언트 빌드에서 중복 실행 방지)
        if (!isServer) {
          return typeof nextConfig.webpack === 'function'
            ? nextConfig.webpack(config, context)
            : config;
        }

        const shouldRun =
          runOn === 'both' ||
          (runOn === 'build' && !dev) ||
          (runOn === 'dev' && dev);

        if (shouldRun) {
          config.plugins = config.plugins || [];
          config.plugins.push(new MetadataWebpackPlugin(pluginConfig));
        }

        // 기존 webpack 설정 체이닝
        if (typeof nextConfig.webpack === 'function') {
          return nextConfig.webpack(config, context);
        }

        return config;
      },
    };
  };
}

/**
 * Webpack 플러그인 클래스 (Webpack 모드용)
 */
class MetadataWebpackPlugin implements WebpackPluginInstance {
  private config: PluginConfig;
  private hasRun: boolean = false;

  constructor(config: PluginConfig) {
    this.config = config;
  }

  apply(compiler: Compiler): void {
    const pluginName = 'MetadataWebpackPlugin';

    // 컴파일 시작 시 분석 실행
    compiler.hooks.beforeCompile.tapAsync(
      pluginName,
      async (_params, callback) => {
        // 중복 실행 방지
        if (this.hasRun) {
          return callback();
        }
        this.hasRun = true;

        try {
          await runMetadataAnalysis(this.config, compiler.context);
          callback();
        } catch (error) {
          callback(error as Error);
        }
      }
    );

    // 개발 모드에서 watch 재빌드 시 플래그 리셋
    compiler.hooks.watchRun.tap(pluginName, () => {
      // 필요시 재분석 로직 추가
    });
  }
}
